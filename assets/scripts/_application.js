// Generated by CoffeeScript 1.6.1
'use strict';
/* --------------------------------------------
     Begin Ball.coffee
--------------------------------------------
*/

var Ball, HeadsUp, Player, animationLoop, animationLoopId, ball, baseSize, calcSpeed, canvas, context, controlCallback, controller, delta, fpsOutput, headsUp, lastTime, playerOne, playerTwo, random, randomInteger;

Ball = (function() {

  function Ball() {}

  Ball.prototype.init = function() {
    var self, velocityMax, velocityMin;
    self = this;
    this.color = 'rgb(240, 240, 240)';
    this.size = baseSize;
    this.half = this.size / 2;
    this.position = {
      x: (canvas.width / 2) - this.half,
      y: (canvas.height / 2) - this.half
    };
    velocityMin = -10;
    velocityMax = 10;
    this.velocity = {
      x: (Math.random() * (velocityMax - velocityMin)) + velocityMin,
      y: (Math.random() * (velocityMax - velocityMin)) + velocityMin
    };
    this.correctVelocity();
    return this;
  };

  Ball.prototype.correctVelocity = function() {
    var speedThreshold;
    speedThreshold = 5;
    if (this.velocity.x < 0) {
      this.directionX = 'left';
      if (this.velocity.x > -speedThreshold) {
        this.velocity.x = -speedThreshold;
      }
    } else {
      this.directionX = 'right';
      if (this.velocity.x < speedThreshold) {
        this.velocity.x = speedThreshold;
      }
    }
    if (this.velocity.y < 0) {
      this.directionY = 'up';
      if (this.velocity.y > -speedThreshold) {
        return this.velocity.y = -speedThreshold;
      }
    } else {
      this.directionY = 'down';
      if (this.velocity.y < speedThreshold) {
        return this.velocity.y = speedThreshold;
      }
    }
  };

  Ball.prototype.detectCollisionWithPaddle = function() {
    var ballY, collision, paddleY;
    if (this.directionX === 'left' && this.position.x <= playerOne.position.x + playerOne.width) {
      ballY = this.position.y;
      paddleY = playerOne.position.y;
      if (ballY >= paddleY && ballY <= (paddleY + playerOne.height)) {
        this.directionX = 'right';
        collision = true;
      }
    } else if ((this.position.x + this.size) >= playerTwo.position.x) {
      ballY = this.position.y;
      paddleY = playerTwo.position.y;
      if (ballY >= paddleY && ballY <= (paddleY + playerTwo.height)) {
        this.directionX = 'left';
        collision = true;
      }
    }
    if (collision) {
      this.velocity.x = -(this.velocity.x * 1.05);
    }
    return this;
  };

  Ball.prototype.detectCollisionWithCeilingOrFloor = function() {
    var collision;
    if (this.directionY === 'up' && this.position.y <= 0) {
      this.directionY = 'down';
      collision = true;
    } else if (this.position.y >= canvas.height - this.size) {
      this.directionY = 'up';
      collision = true;
    }
    if (collision) {
      this.velocity.y = -this.velocity.y;
    }
    return this;
  };

  Ball.prototype.draw = function() {
    context.fillStyle = this.color;
    context.fillRect(this.position.x, this.position.y, this.size, this.size);
    return this;
  };

  Ball.prototype.isStillInPlayingField = function() {
    var insideLeft, insideRight;
    insideLeft = this.position.x > -(baseSize * 5);
    insideRight = this.position.x + this.size < canvas.width + (baseSize * 5);
    return insideLeft && insideRight;
  };

  Ball.prototype.update = function() {
    if (this.isStillInPlayingField()) {
      this.detectCollisionWithPaddle();
      this.position.x += calcSpeed(this.velocity.x);
      this.detectCollisionWithCeilingOrFloor();
      this.position.y += calcSpeed(this.velocity.y);
    } else {
      this.updateScoreStates();
      this.init();
    }
    if (playerOne.score === 3 || playerTwo === 3) {
      console.log('GAME OVER');
      window.cancelAnimationFrame(animationLoopId);
    }
    return this;
  };

  Ball.prototype.updateScoreStates = function() {
    var outsideLeft;
    outsideLeft = this.position.x < -(baseSize * 5);
    if (outsideLeft) {
      playerTwo.score += 1;
    } else {
      playerOne.score += 1;
    }
    return this;
  };

  return Ball;

})();

/* --------------------------------------------
     Begin HeadsUp.coffee
--------------------------------------------
*/


HeadsUp = (function() {

  function HeadsUp() {}

  HeadsUp.prototype.init = function() {
    this.netColor = 'rgba(240, 240, 240, 0.25)';
    this.netWidth = Math.round(baseSize / 2);
    this.netLineWidth = Math.round(this.netWidth / 3);
    this.netX = (canvas.width / 2) - (this.netWidth / 2);
    this.charPatterns = [[1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1]];
    return this;
  };

  HeadsUp.prototype.draw = function() {
    this.drawNet();
    this.drawScores();
    return this;
  };

  HeadsUp.prototype.drawNet = function() {
    var netY;
    context.fillStyle = this.netColor;
    context.strokeStyle = this.netColor;
    netY = 0;
    context.lineWidth = this.netLineWidth;
    context.beginPath();
    while (netY < canvas.height) {
      context.moveTo(this.netX, netY + this.netLineWidth);
      context.lineTo(this.netX + this.netWidth, netY + this.netLineWidth);
      netY += this.netLineWidth * 2;
    }
    context.closePath();
    context.fill();
    return context.stroke();
  };

  HeadsUp.prototype.drawScores = function() {
    var score;
    score = '' + playerOne.score;
    this.drawScoreCharacters(1, score);
    score = '' + playerTwo.score;
    this.drawScoreCharacters(2, score);
    return this;
  };

  HeadsUp.prototype.drawScoreCharacters = function(player, score) {
    var char, charCount, charWidth, pattern, posX, posY, scoreStartY, startX, startY, unitLong, unitShort, _i, _len, _ref;
    charCount = score.length;
    charWidth = baseSize * 4;
    unitLong = baseSize * 3;
    unitShort = baseSize;
    startX = canvas.width / 2;
    startY = scoreStartY = baseSize * 2;
    if (player === 1) {
      startX += (this.netWidth / 2) + (baseSize * 2);
    } else {
      startX -= (baseSize * 2) + (charWidth * charCount) - this.netWidth;
    }
    posX = startX;
    posY = startY;
    context.lineWidth = baseSize;
    context.beginPath();
    _ref = score.split('');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      char = _ref[_i];
      char = parseInt(char, 10);
      pattern = this.charPatterns[char];
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[0] + ')';
      context.fillRect(posX, posY, unitLong, unitShort);
      posY += baseSize * 2;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[6] + ')';
      context.fillRect(posX, posY, unitLong, unitShort);
      posY += baseSize * 2;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[3] + ')';
      context.fillRect(posX, posY, unitLong, unitShort);
      posX = startX;
      posY = startY;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[5] + ')';
      context.fillRect(posX, posY, unitShort, unitLong);
      posY += baseSize * 2;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[4] + ')';
      context.fillRect(posX, posY, unitShort, unitLong);
      posX = startX + baseSize * 2;
      posY = startY;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[1] + ')';
      context.fillRect(posX, posY, unitShort, unitLong);
      posY += baseSize * 2;
      context.fillStyle = 'rgba(180, 180, 180, ' + pattern[2] + ')';
      context.fillRect(posX, posY, unitShort, unitLong);
      startX += charWidth;
      posX = startX;
      posY = startY;
    }
    return this;
  };

  HeadsUp.prototype.update = function() {
    return this;
  };

  return HeadsUp;

})();

/* --------------------------------------------
     Begin Player.coffee
--------------------------------------------
*/


Player = (function() {

  function Player() {}

  Player.prototype.init = function(playerNumber) {
    var self;
    self = this;
    this.playerNumber = playerNumber;
    this.color = 'rgb(240, 240, 240)';
    this.direction = false;
    this.score = 0;
    this.height = baseSize * 8;
    this.width = baseSize;
    this.position = {
      x: this.playerNumber === 1 ? 20 : canvas.width - 20 - this.width,
      y: (canvas.height / 2) - (this.height / 2)
    };
    this.animateTo = this.position;
    this.newPositionY = 0.5;
    this.maxPositionY = canvas.height - this.height;
    this.velocity = 30;
    return this;
  };

  Player.prototype.draw = function() {
    context.fillStyle = this.color;
    context.fillRect(this.position.x, this.position.y, this.width, this.height);
    return this;
  };

  Player.prototype.update = function() {
    this.position.y = this.maxPositionY * this.newPositionY;
    return this;
  };

  return Player;

})();

/* --------------------------------------------
     Begin _utils.coffee
--------------------------------------------
*/


random = function(min, max) {
  if (min === void 0) {
    min = 0;
    max = 1;
  } else if (max === void 0) {
    max = min;
    min = 0;
  }
  return (Math.random() * (max - min)) + min;
};

randomInteger = function(min, max) {
  if (max === void 0) {
    max = min;
    min = 0;
  }
  return Math.floor(Math.random() * (max + 1 - min)) + min;
};

/* --------------------------------------------
     Begin _bootstrap.coffee
--------------------------------------------
*/


delta = 0;

fpsOutput = document.querySelector('.fps');

lastTime = 0;

animationLoop = function(now) {
  var fps;
  delta = now - lastTime;
  lastTime = now;
  fps = Math.round(1000 / delta);
  fpsOutput.innerHTML = fps;
  canvas.width = canvas.width;
  ball.draw();
  headsUp.draw();
  playerOne.draw();
  playerTwo.draw();
  ball.update();
  headsUp.update();
  playerOne.update();
  playerTwo.update();
  window.requestAnimationFrame(animationLoop);
};

calcSpeed = function(speed) {
  return (speed * delta) * (60 / 1000);
};

controlCallback = function(t, a, controlIndex, value) {
  var paddle;
  if (controlIndex === 3 || controlIndex === 14) {
    paddle = playerOne;
  }
  if (controlIndex === 11 || controlIndex === 22) {
    paddle = playerTwo;
  }
  if (paddle) {
    value /= 128;
    paddle.newPositionY = -(value - 1);
  }
};

document.getElementById('Jazz').MidiInOpen(0, controlCallback);

controller = new Option(' ', ' ', true, true);

canvas = document.createElement('canvas');

context = canvas.getContext('2d');

document.body.appendChild(canvas);

canvas.width = document.body.clientWidth;

canvas.height = document.body.clientHeight;

baseSize = Math.round(canvas.height * 0.015);

ball = new Ball();

ball.init();

playerOne = new Player();

playerOne.init(1);

playerTwo = new Player();

playerTwo.init(2);

headsUp = new HeadsUp();

headsUp.init();

animationLoopId = window.requestAnimationFrame(animationLoop);
